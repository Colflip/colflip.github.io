<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[阶级固化现象越来越严重，向上的路越来越难]]></title>
    <url>%2F2019%2F03%2F14%2F%E9%98%B6%E7%BA%A7%E5%9B%BA%E5%8C%96%E7%8E%B0%E8%B1%A1%E8%B6%8A%E6%9D%A5%E8%B6%8A%E4%B8%A5%E9%87%8D%EF%BC%8C%E5%90%91%E4%B8%8A%E7%9A%84%E8%B7%AF%E8%B6%8A%E6%9D%A5%E8%B6%8A%E9%9A%BE%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;一个理想的社会，一定是流动的。人才、资源和其他因素可以自由流动，信息能够充分传播，不受任何因素限制，也不会存在信息的不对等。但现实中，这种理想状态是不存在的，虽然互联网的形成在一定程度上增强了信息的传播，但当信息量过大过多时，互联网便成了负面因素，因为从无穷无尽的信息中找出有用的信息，对于个人来说近乎于不可能，而有些人可以借助超级计算机等资源找出有用信息，本质上还是没有有效传播信息，或者说也没有形成人人平等的接受信息。&emsp;&emsp;而在这种情况下，那些既得利益者或者说有资源的人，便形成了对社会资源的垄断。无可争议，阶级固化正在加重，掌握社会资源多的人，他们的后代更容易获得、调动社会资源，更容易成功。这个道理自古皆然，但现在，越来越严重。这种固化现象，在其他领域已经很明显。但现在，教育领域也被逐渐侵蚀。过去，富人因自身素养、学校能力的问题，很多富二代并未得到很好的教育，甚至反而被惯坏了，导致富不过三代甚至富不过二代，造成了中国社会阶层的流动通畅（当然也有中国社会巨变等其他原因）。在未来，教育资源将向富人集中，富人的后代将得到更好的教育，富二代将逐渐从一个贬义词，进化成中性词、褒义词。当教育也完成固化，教授的儿子还是教授，富人的孩子也拥有很高的知识水平时，那穷人的孩子将彻底没有机会翻身。 &emsp;&emsp;一场又一场的技术革命，让人逐渐脱离被饿死的命运，让人们不用为生计担忧，而当人们衣食无忧时，也是阶级流动停止的时候，而且“奶头乐”行动已经开始。精英永远是精英，而普通人永远是普通人。 &emsp;&emsp;向上的路很难很远，希望自己能通过奋斗，上一个台阶，否则以后会越来越难。 &emsp;&emsp;如何评价美国最大规模大学招生舞弊： 50 人被捕，耶鲁斯坦福都卷入？&emsp;&emsp;College Admissions Scandal&emsp;&emsp;不要让阶级固化了教育&emsp;&emsp;美国的危机：阶层固化]]></content>
      <categories>
        <category>生活杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[要看的纪录片]]></title>
    <url>%2F2019%2F03%2F09%2F%E8%A6%81%E7%9C%8B%E7%9A%84%E7%BA%AA%E5%BD%95%E7%89%87%2F</url>
    <content type="text"><![CDATA[记录片 我在故宫修文物av3924328 国脉·中国国家博物馆av4152415 御膳房av4004813 帝陵 av4619981 中国通史av5670296 北京中轴线av4378167 大明宫av1730716 大运河av4139898 超级工程av645654210.航拍中国av832040911.舌尖上的中国第一季av3585546，第二季av423188112.长城av312201913.楚国八百年203714.台北故宫av357864815.汉字五千年av25026316.河西走廊av222987417.新丝绸之路av124217918.史说汉字av248358919.海昏侯大墓av356342820.复活的军团av52244021.圆明园av156305322.东方帝王谷av248432823.望长安av468683124.布衣中国av880217625.大汉帝国av533298826.中华文明av347972127.历史的拐点av595752228.世界遗产在中国av473436229.再说长江av212052930.美丽中国av225160631.敦煌av503153832.敦煌画派4035333.与全世界做生意av283750234.留住手艺av319331035.第三极av866806936.当卢浮宫遇见紫禁城av145823237.天河av293302938.光阴·西藏的西藏av447113139.中国高铁av970176340.筑梦路上av505343041.故宫100av411458942.我们诞生在中国av734661643.锦绣纪av629451344.古兵器大揭秘av583857645.大国重器av180633346.寻味顺德av467355947.味道云南av369276848.客从合出来av108879049.南宋av361303650.神秘的西夏av4670883]]></content>
      <categories>
        <category>人文知识</category>
      </categories>
      <tags>
        <tag>纪录片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom Markdown常用技巧]]></title>
    <url>%2F2019%2F03%2F08%2FAtom-Markdown%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[常用快捷键&emsp;&emsp;只需要输入如下内容, Atom编辑器会自动提示，回车之后即可进入对应的状态。 加粗文字 : b 代码: c 斜体: i 图像: img 链接: l 权声明: legal 填充文字: lorem 引用编号代码格式:ref 外联引用指定编号的链接: rl 外联引用指定编号图片: rimg todo列表 :t 表格： table]]></content>
      <categories>
        <category>编程开发</category>
      </categories>
      <tags>
        <tag>Atom</tag>
        <tag>Markdown</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[互联网络的结构]]></title>
    <url>%2F2019%2F03%2F07%2F%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[静态互连网络&emsp;&emsp;互连网络可以分为两类：静态互连网络（static interconnection network）和动态互连网络（dynamic interconnection network）。静态互连网络是指各节点之间有固定的连接通路，且在运行中不能改变的网络。而动态互连网络则是由交换开关构成、可按运行程序的要求动态的改变连接状态的网络。静态互连网路比较适合用于构造通信模式预测或用静态连接实现的计算机。 线性阵列环和带环循环移数网络树形和星形胖树形网格形和环网形超立方体动态互连网络总线多级互连网络&emsp;&emsp;（1）Omega网络&emsp;&emsp;下图是一个88的Omega网络，共有3级，每级由4个2 2开关构成。级间互连采用均匀洗牌模式。网络的左侧是8个输入，右侧是8个输出。 &emsp;&emsp;一般来说，一个N输入的Omega网络有log_2N级，每级用\frac{N}{2} 个2 2开关模块，共需要 Nlog_2\frac{N}{2}个开关。每个开关模块均采用单元控制方式。&emsp;&emsp;（2）多级立方体网络&emsp;&emsp;多级立方体网络采用二功能（直送和交换）的2 2开关和交换函数构成，其级间互连按照从左到右的次序分别是C_0、C_1、C_2 互连函数。可以通过设置开关的工作状态来得到不同的多级互连网络。]]></content>
      <categories>
        <category>专业知识</category>
      </categories>
      <tags>
        <tag>计算机系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[互联网络的基本概念]]></title>
    <url>%2F2019%2F03%2F07%2F%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;此处概念限定为“互连”，与“互联”区分。 互连网络的功能和特征&emsp;&emsp;互联网络（interconnection network）是一种由开关元件按照一定拓扑结构和控制方式构成的网络，用来实现计算机系统中结点之间的相互连接。这些节点可以是处理器、存储模块后其他设备。从拓扑结构角度，互联网络是从输入结点到输出结点之间的一组互连或映射（mapping）。 &emsp;&emsp;互连网络已经成为并行计算机系统的一个关键组成部分。随着各个领域对高性能计算机的要求越来越高，多处理机和多计算机系统的规模越来越大，对处理器之间或处理单元与存储模块之间通信的速度和灵活性的要求也越来越高。因此，它对计算机系统的性能价格比有着决定性的影响。&emsp;&emsp;可以从以下4个不同的方面来描述互连网络。&emsp;&emsp;（1）定时方式：有同步和异步两种。&emsp;&emsp;同步系统使用一个统一的时钟。它可以将数据同时播送到所有处理器结点中， 也可以使所有结点同时与相邻的结点进行通信（若无冲突）。而异步系统没有统一的时钟，系统中的各个处理机都是独立地工作。&emsp;&emsp;（2）交换方式：有线路交换和分组交换两种。&emsp;&emsp;（3）控制策略：有集中式和分散式两种。&emsp;&emsp;（4）拓扑结构：有静态和动态两种。 互连函数&emsp;&emsp;为反应不同互连函数的连接特性，每种互连网络可用一组互连函数（interconnection function）来描述。用变量x表示输入（设x=0,1，···，N-1），用函数f(x)表示输出，通过数学表达式建立输入端与输出端的一一对应关系。即在互连函数f的作用下，输入端x连接到输出端f（x）。x和f（x）可以用二进制表示，也可以用十进制表示。&emsp;&emsp;互连函数反映了网络输入数组和输出数组之间对应的置换关系或排列关系，所以互连函数有事也称为置换（permutation）函数或排列函数。&emsp;&emsp;互连函数f（x）有时可以采用循环表示，即（x_0x_1x_2···x_{j-1}）。它表示： $$ f(x_0)=x_1, f(x_1)=x_2, ···, f(x_{j-1})=x_0 $$ &emsp;&emsp;其中，j称为该循环的长度。&emsp;&emsp;下面介绍几种常用的基本互连函数及其主要特征。 交换函数&emsp;&emsp;交换函数用于实现二进制地址编码中第k位互反的输入端与输出端的连接。其表达式为： $$ E_k(x_{n-1}x_{n-2}···x_{k+1}x_{k}x_{k-1}···x_1x_0)=x_{n-1}x_{n-2}···x_{k+1} \overline{x_k} x_{k-1}···x_1x_0 $$ &emsp;&emsp; 交换函数主要用来构建立方体网络和各种超立方体互连网络。它共有n=log_2N 种互连函数。N为结点个数。 均匀洗牌函数&emsp;&emsp;均匀洗牌函数（shuffle）定义为：将输入端分成数目相等的两半，前一半和后一半按类似均匀混洗扑克牌的方式交叉的连接到输出端（输出端相当于混洗的结果），其函数可表示为： $$ S(x_{n-1}x_{n-2}···x_{2}x_{1})=x_{n-2}···x_2x_1x_{n-1} $$ &emsp;&emsp; 即把输入端的二进制编号循环左移一位。&emsp;&emsp; 逆均匀洗牌函数于此类似，是将输入端的二进制编号循环右移一位而得到所连接的输出端编号。&emsp;&emsp; 逆均匀洗牌函数是均匀洗牌函数的逆函数。两者的输入端与输出端正好互换位置（互为镜像）。&emsp;&emsp; 用它们代表的链路和交换开关多级组合起来可构成Omega网络与逆Omega网络。 蝶式函数&emsp;&emsp;蝶式互连函数（butterfly）定义为： $$ B(x_{n-1}x_{n-2}···x_1x_0)=x_0x_{n-2}···x_1x_{n-1} $$ &emsp;&emsp;即把输入端的二进制编号的最高位与最低位互换位置，便得到了输出端的编号。&emsp;&emsp;与均匀混洗函数类似，只用蝶式函数不能实现任意结点之间的连接，但是蝶式变换与交换变换的多级组合可作为构成方体多级网络的基础。 反位序函数&emsp;&emsp;反位序函数是将输入端二进制编号的位序颠倒过来求得相应输出端的编号。其互连函数为： $$ R(x_{n-1}x_{n-2}···x_1x_0)=x_0x_1x_2···x_{n-2}x_{n-1} $$ &emsp;&emsp;对于N=8的情况，正好B(x)函数等于R(x)函数，其变换图形如下。 PM2I函数&emsp;&emsp;PM2I函数是一种移数函数，它是将各输入端都循环移动一定的位置后连到输出端。其函数为： $$ PM2_{+i}(x)=(x+2^i) mod N $$ $$ PM2_{-i}(x)=(x-2^i) mod N $$ &emsp;&emsp;其中，0&lt;=x&lt;=N-1, 0&lt;=i&lt;=n-1, n=log_2N, N为结点数。显然，PM2I互连网络共有2n个互连函数。&emsp;&emsp;当N=8时，有6个PM2I函数： $$ PM2_{+0}: (0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;7 ) $$ $$ PM2_{-0}: (7&nbsp;6 &nbsp;5&nbsp; 4 &nbsp;3 &nbsp;2 &nbsp;1&nbsp; 0 ) $$ $$ PM2_{+1}: (0&nbsp; 2 &nbsp;4 &nbsp;6 )(1&nbsp; 3 &nbsp;5&nbsp; 7 ) $$ $$ PM2_{-1}: (6&nbsp; 4&nbsp; 2&nbsp; 0 )(7&nbsp; 5&nbsp; 3&nbsp; 1 ) $$ $$ PM2_{\pm2}: (0&nbsp; 4)(1&nbsp; 5)(2&nbsp; 6)(3&nbsp; 7) $$ &emsp;&emsp;下图画出了其中3个函数的变形图形。 &emsp;&emsp;PM2I函数是构成数据变换网络的基础。&emsp;&emsp;阵列计算机ILLIAC IV采用PM2_{\pm0}和PM2_{\pm \frac{n}{2}}构成互连网络，实现各处理单元之间的上下左右互连，如下图。 互连函数的性能参数&emsp;&emsp;网络通常是用有向边或无向边连接有限个结点的图来表示。互连网络的主要特征参数有：&emsp;&emsp;（1）网络规模（network size）：网络中结点的个数。它表示该网络所能连接的部件的数量、&emsp;&emsp;（2）节点度（node degree）：与结点相连接的边数（通道数），包括入度（in degree）和出度（out degree）。进入结点的边数称为入度，从结点出来的边数称为出度。&emsp;&emsp;（3）距离：对于网络中的任意两个结点，从一个结点出发到另一个节点终止所需要跨越的边数的最小值。&emsp;&emsp;（4）网络直径（network diameter）：网络中任意两个结点之间距离的最大值。网络直径应尽可能地小。&emsp;&emsp;（5）结点之间的线长：两个结点之间连线的长度，用米、千米等表示。&emsp;&emsp;（6）等分宽度：当某一网路被分割成相等的两半时，沿切口的边数（通道数）的最小值称为通道等分宽度（channel bisection width），用b表示。而线等分宽度为B=b*w。其中w为通道宽度（用位表示）。该参数主要反映了网络最大流量。&emsp;&emsp;（7）对称性：从任何结点看到的拓扑结构都是相同的网络称为对称网络（symmetric network）。对称网络比较容易实现，编程也比较容易。]]></content>
      <categories>
        <category>专业知识</category>
      </categories>
      <tags>
        <tag>计算机系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo NexT网站个性化阿萨德才]]></title>
    <url>%2F2019%2F03%2F06%2FHexo-NexT%E7%BD%91%E7%AB%99%E4%B8%AA%E6%80%A7%E5%8C%96%E9%98%BF%E8%90%A8%E5%BE%B7%E6%89%8D%2F</url>
    <content type="text"><![CDATA[添加字数统计、阅读时长&emsp;&emsp;适用于next 6 以后版本，分两步完成 安装 npm install hexo-symbols-count-time —save 主配置文件（根hexo目录） 添加12345symbols_count_time: symbols: true time: true total_symbols: true total_time: true 添加404公益界面&emsp;&emsp;创建页面，在 Hexo 文件夹根目录下 /source/404/index.html； 12345678910111213141516---title: 404 Not Found：该页无法显示toc: falsecomments: falsepermalink: /404---&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;404&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript" src="//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js" homePageName="返回首页" homePageUrl="https://yohua.ml"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; &emsp;&emsp;部署 1hexo d -g 添加网易云音乐&emsp;&emsp;在网易云音乐生成外链，将代码放置合适位置即可。1&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=46 src="//music.163.com/outchain/player?type=2&amp;id=25638273&amp;auto=0&amp;height=46"&gt;&lt;/iframe&gt;]]></content>
      <categories>
        <category>编程开发</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指令级并行之动态分支预测技术]]></title>
    <url>%2F2019%2F03%2F06%2F%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C%E4%B9%8B%E5%8A%A8%E6%80%81%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;当要提高ILP（指令级并行）时，控制相关就是会成为主要限定因素之一。所开发的ILP越多，控制相关的制约性就越大，分支预测就要求有更高的准确度。对于每个时钟周期流出多条指令（若为n条，就称为n流出）的处理机来说是非常重要的。这是因为：①在n流出的处理机中，遇到分支指令的可能性增加了n倍。要给处理机连续提供指令，就需要预测分支的结果；②Amdahl定律告诉我们，机器的CPI越小，控制停顿的相对影响就越大。&emsp;&emsp;前面介绍的集中静态处理分支指令的方法，如预测成功和延迟分支。在这些方法中，所进行的操作是预先定义好的，与分支的实际执行情况无关。下面讨论动态的进行分支处理的方法。这些方法是在程序运行的时候，根据分支指令过去的表现来预测其将来的行为。如果分支行为发生了变化，预测结果也随之改变。因此有较好的预测准确度和适应性。&emsp;&emsp;分支预测的有效性不仅取决于其准确性，而且还与预测正确和不正确两种情况下的分支开销有密切关系。这些分支开销是由流水线的结构、预测的方法和预测错误时的恢复策略等诸因素决定的。&emsp;&emsp;采用这些动态分支预测技术的目的有两个：预测分支是否成功和尽快找到分支目标地址（或指令），从而避免控制相关造成流水线停顿。&emsp;&emsp;在这些方法中，需要解决以下关键问题：①如何记录分支的历史信息；②如何根据这些信息来预测分支的去向（甚至取到指令）。&emsp;&emsp;预测错误时，要作废已经预取和分析的指令，恢复现场，并从另一条分支路径上重新取指令，为了能恢复现场，需要在执行预测的目标指令之前将现场保持起来。 采用分支历史表&emsp;&emsp;分支历史表（Branch History Table，BHT）有时也称为分支预测缓冲器（Branch Prediciton Buffer）。这种方法是最简单的动态分支预测法。它用BHT来记录分支指令最近一次或几次的执行情况（成功或不成功），并据此进行预测。如果只执行分支指令最近一次的历史，BHT中只需要1位二进制位，是最简单的了。为了提高预测的准确度，常采取两位二进制位来记录历史。有研究结果表明，两位分支预测的性能与n位（n&gt;2）分支预测的性能差不多。因而大多数处理机是采用分支预测。下面介绍这种方法。&emsp;&emsp;两位分支预测的状态转换如下图。其中，在00和01状态下，预测分支不成功；在10和11状态下，预测分支成功。连线边上注明了分支指令的实际执行情况。只有连续两次预测错误，才会改变对分支去向的预测。在11状态下连续两次错误预测错误，状态将变为00（预测分支不成功）。 &emsp;&emsp;两位分支预测的操作有两个步骤：①分支预测；②状态修改。当分支指令到达译码段（ID）时，根据从BHT读出的信息进行分支预测，如果是“预测成功”，那么就从分支目标地址取后续的指令。等分支指令的实际执行结果出来后，如果发现预测正确，就继续处理后续的指令，流水线没有断流。否则，就要作废已经预取和分析的指令，恢复现场，并从另一条分支路径中重新取指令。不管是哪种情况，都要按照上图状态进行修改。&emsp;&emsp;在BHT方法中，只对分支是否成功进行预测，对分支目标地址没有提供支持。所以它只有在以下情况中有用：判定分支是否成功所需的时间大于确定分支目标地址所需的时间。在前述5段经典流水线中，由于判定分支是否成功和计算分支目标地址都是在ID段完成，所以BHT方法不会给该流水线带来好处。&emsp;&emsp;一般来说，采用4K的BHT就可以了，如果要进一步提高预测准确率，需要采用更复杂的预测方法。&emsp;&emsp;BHT可以跟分支指令一起存放在指令Cache中，也可以用一个专门的硬件来实现。如果是前者，在取指阶段，就把历史位一起读出来。如果是后者，就在取指令的同时，用指令地址的低位（例如低12位）去访问BHT，读出历史位。 采用分支目标缓冲器&emsp;&emsp;在高性能流水线中，特别是在多流出的处理机中，只准确的预测分支还不够，还要能够提供足够的指令流。许多现代的处理器都要要求每个时钟周期能提供4~8条指令。这需要尽早知道分支是否成功，尽早知道分支目标得治，尽早获取分支目标指令。&emsp;&emsp;对于前述5段流水线，BHT方法是在ID段对BHT进行访问，所以在ID段的末尾，能够获得分支目标地址（在ID段计算出）、顺序下一条指令地址（在IF段计算出）以及预测的结果，如果能再提前一拍（即在IF段）就知道这些信息，那么分支开销就可以减少为0。分支目标缓冲器（Branch Target Buffer，BTB）能够实现这一点。BTB有时也称为分支目标Cache。 &emsp;&emsp;如上图，可以把它看成是用专门硬件实现的一张表格。表格的每一项至少有两个字段：①执行过的成功分支指令的地址；②预测的分支目标地址。第一个字段作为该表的匹配标识。在每次取指令的同时，我们把该指令的地址与BTB中的所有项目的第一个字段进行比较。如果能匹配，就可确定该指令时分支指令且上一次执行时分支成功，据此可以预测这次执行也将分支成功，其分支目标地址由匹配项的第二个字段给出。如果没有匹配的，就把当前指令当作普通的指令（即不是分支指令）来执行。 &emsp;&emsp;当采用BTB后，在流水线各个阶段进行的相关操作如上图所示。BTB的另一种形式是在分支目标缓冲器中存储一条或者多条分支目标处的指令。有的实现方案还保留了分支目标地址，有的则降之去掉了。这种方案的3个潜在好处是：①更快地获得分支目标处的指令；②可以一次提供分支目标处的多条指令，这对于多流出处理器是很有必要的；③便于进行分支折叠优化。]]></content>
      <categories>
        <category>专业知识</category>
      </categories>
      <tags>
        <tag>计算机系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魅族手机剩余30%电量自动关机解决方法]]></title>
    <url>%2F2019%2F03%2F06%2F%E9%AD%85%E6%97%8F%E6%89%8B%E6%9C%BA%E5%89%A9%E4%BD%9930-%E7%94%B5%E9%87%8F%E8%87%AA%E5%8A%A8%E5%85%B3%E6%9C%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;魅族官方回复&emsp;&emsp;您好，请您按照以下方法排除故障：&emsp;&emsp;1、电池的电量计是什么：用于监测手机电池的电压/电流，计算电量的芯片。&emsp;&emsp;2、电量计不准确可能导致的情况：充不满电、不掉电、快速掉电、电量跳变、高电量关机……&emsp;&emsp;3、电量计校准方法：&emsp;&emsp;方法一：满电后持续充电&emsp;&emsp;使用充电器给手机充电，充满至100%后继续保持充电状态1小时左右，即可完成电量计校准。&emsp;&emsp;注意过程中手机需保持休眠，不可**作或者APP后台唤醒。（建议睡觉时，将手机清理后台、关闭网络充电一晚上。）&emsp;&emsp;方法二：完整充放电并静置&emsp;&emsp;手机先充满电，然后正常使用至没电关机，关机后等待2小时再进行充电即可校准电量计。&emsp;&emsp;方法三：低电量关机静置&emsp;&emsp;当手机电量低于10%时，手动将手机关机，1小时后再开机即可校准电量计。 &emsp;&emsp;实测方法二有效，需要低电量关机充满电并保持充电状态1小时，重复两次。完成电量校准。 相关链接https://service.meizu.com/faq/type/17002?sub=17004]]></content>
      <tags>
        <tag>魅族</tag>
        <tag>手机</tag>
        <tag>手机电池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指令级并行之多指令流出技术]]></title>
    <url>%2F2019%2F03%2F06%2F%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C%E4%B9%8B%E5%A4%9A%E6%8C%87%E4%BB%A4%E6%B5%81%E5%87%BA%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;虽然希望CPI越小越好，但如果是每次只流出一条指令，CPI就不可能小于1。如果想再进一步提高性能，使CPI小于1，就必须采取多柳树技术（multiple issure），在每个时钟周期流出多条指令。&emsp;&emsp;多流出处理机有两种基本风格：超标量（superscalar）和超长指令字VLIW（Very Long Instruction Word）。超标量在每个时钟周期流出的指令条数不固定，依代码的具体情况而定，不过有个上限。设这个上限为n，就成该处理机为n流出。对于超标量处理机，既可以通过编译器进行静态调度，也可以基于Tomasulo算法进行动态调度。静态调度的超标量处理机易班采用按序执行，而动态调度的处理机一般采用乱序执行。&emsp;&emsp;与超标量处理机不同，VLIW处理机在每个时钟周期流出的指令条数是固定的，这些指令构成一条长指令或者一个指令包，在这个指令包中，指令之间的并行性是通过指令显式地表示出来的。这种处理机的指令调度是由编译器静态完成的。&emsp;&emsp;超标量处理机与VLIW处理机相比有两个优点：&emsp;&emsp;（1）超标量结构对程序员是透明的，因为处理机能自己检测下一条指令能否流出，从而不需要重新排列指令来满足指令的流出。&emsp;&emsp;（2）即使是没有经过编译器针对超标量结构进行调度优化的代码或是旧的编译器生成的代码也可以运行，当然运行的效果不会很好。要想达到很好的效果，方法之一就是使用动态超标量调度技术。 基于静态调度的多流出技术&emsp;&emsp;典型的超标量处理机每个时钟周期可流出1~8条指令。在静态调度的超标量处理机中，指令按序流出。所有的冲突检测都在流出时进行，由硬件检测当前流出的指令之间是否存在冲突以及当前流出的指令与正在执行的指令是否有冲突。如果当前流出的指令序列中，某条指令存在上述冲突，那么就只流出该指令之前的指令。 基于动态调度的多流出技术&emsp;&emsp;在多流出处理机中，动态调度技术是提高性能的一种方法。动态调度不仅在有数据冲突的时候也能提高性能，而且还有可能克服指令流出所受的限制。尽管从硬件角度看，在每个时钟周期最多只能启动一个整数和一个浮点操作的执行，但是动态调度可以使得在流出时不受这个限制，至少在保留站全部被占用之前是如此。&emsp;&emsp;假如要对Tomasulo算法进行拓展，使之能够支持超标量流水线，但是又不想乱序的向保留站流出指令，应为这会破坏程序语义。为了充分利用动态调度的好处，应该去掉每个时期周期只能流出一条整数指令和一条浮点操作指令的限制。但这会大大地增加指令流出的硬件复杂度。&emsp;&emsp;另一种比较简单的方法是：将整数所用的表结构与浮点用的表结构分离，分别进行处理，这样就可以同时流出一条浮点指令和一条整数指令到各自的保留站中。&emsp;&emsp;有两种不同的方法可以用来在采用动态调度的处理机中实现多流出。他们都是监理在这样一个认识之上的：关键在于对保留站的分配和对流水线控制表格的修改。一种方法是在半个时钟周期里完成露出步骤，这样一个时钟周期就能处理两条指令。另一种方法是设置一次能同时处理两条指令的逻辑电路。线代的流出4条或4条以上指令的超标量处理机经常是两种方法都采用。 超长指令字技术&emsp;&emsp;与超标量不同，超长指令字技术在指令流出时不需要进行复杂的冲突检测，而是依靠编译器在编译时找出指令之间潜在的并行性，并通过指令调度把可能出现的数据冲突减少到最小，最后把能并行执行的多条指令组装成一条很长的指令。这种指令经常是100到几百位，超长指令字因此得名。&emsp;&emsp;在VLIW处理机中一般设置多个功能部件。相应的，指令字也被分割成多个字段，每个字段称为一个操作槽，直接独立地控制一个功能部件。为了使功能部件充分忙碌，程序指令序列中应有足够的并行性，从而尽量填满每个操作槽。这种并行性是依靠编译器来挖掘的。编译器把循环展开，并在展开后的代码中进行指令调度。&emsp;&emsp;在VLIW处理机中，所有的处理和指令安排都是由编译器完成的，它不需要超标量处理机中用于指令流出控制的硬件，因而控制硬件比较简单。特别是当流出宽度增加时，VLIW技术的优点更明显。 超长指令字技术缺点&emsp;&emsp;（1）程序代码长度增加&emsp;&emsp;原因有：一个是为了提高并行性而进行的大量的循环展开，另一个是指令字中的操作槽并非总能填满。虽然编译器会尽量使得各操作部件充分忙碌，但总会出现无法安排指令到操作部件执行的情况，这时指令字中与该操作部件对应的操作槽就没有被利用起来，这会造成空间上的浪费。&emsp;&emsp;为解决此问题，可采用指令共享立即数字段的方法，或者采用指令压缩存储、调入Cache或译码时展开的方法。&emsp;&emsp;（2）采用了琐步机制&emsp;&emsp;由于没有冲突检测硬件，早期VLIW技术都采用琐步机制。在新近的VLIW处理机中，各功能部件有了更多的独立性。可以通过设置适当的硬件动态检测机制，来允许指令流出后的非同步执行。&emsp;&emsp;（3）机器代码的不兼容性在VLIW中，编译生成代码时，是充分利用了指令集的特点以及具体流水线结构的细节（如指令流出数目、功能单元延迟时间等都不同）来进行优化的。所以在不同配置的VLIW中，机器代码差别很大。即使是同一系列的VLIW也难以实现机器代码的兼容。&emsp;&emsp;为解决此问题，可以采用机器代码翻译或仿真的方法。这两种方法是解决所有移植问题的通用方法。 多流出处理器受到的限制&emsp;&emsp;主要受以下三方面影响：&emsp;&emsp;（1）程序所固有的指令级并行（ILP）。&emsp;&emsp;（2）硬件实现上的困难。&emsp;&emsp;（3）超变量和超长指令字处理机器固有的技术限制。 超流水线处理机]]></content>
      <categories>
        <category>专业知识</category>
      </categories>
      <tags>
        <tag>计算机系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指令级并行之指令的动态调度]]></title>
    <url>%2F2019%2F03%2F06%2F%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C%E4%B9%8B%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8A%A8%E6%80%81%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在前述的流水线属于静态调度的流水线。在这样的流水线中，当取出的指令与已经在流水线中执行的指令不存在数据相关，或者虽存在数据相关但可以通过定向机制将相关隐藏时，就可以流出这条指令。如果数据相关不能被隐藏，冲突检测硬件就会从使用该数据的指令开始，使流水线停顿（stall），不再取指令和流出指令。&emsp;&emsp;静态调度的流水线依靠编译器对代码进行静态调度，以减少相关和调度。之所以成为静态调度，是因为它不是在程序执行的过程中，而是在编译期间进行代码调度和优化。静态调度通过把相关的指令拉开距离来减少可能产生的停顿。&emsp;&emsp;动态调度是在程序的执行过程中，依靠专门硬件对代码进行调度。许多线代处理器都采用了动态调度技术。动态调度能在保持数据流和异常行为的情况下，通过硬件对指令执行顺序进行重新安排，减少数据相关导致的停顿。&emsp;&emsp;动态调度有许多优点：①能够处理一些编译时情况不明的相关（如涉及存储器访问的相关），并简化了编译器；②能够使本来是面向某一流水线优化编译的代码在其他的流水线（动态调度）上也能高效的执行。当然，动态调度的这些优点是以硬件复杂性的显著增加为代价的。 动态调度的基本思想&emsp;&emsp;前面讨论的简单流水线有一个主演局限性，就是指令时按照程序顺序流出和按序执行的。如果某条指令在流水线中被停顿了，那么后面所有的指令都停止前进。如果相近的指令存在相关，近很可能导致冲突，引起停顿。如果系统中有多个功能部件，那么这些部件很可能因为没有指令可处理而处于空闲状态，系统效率低下。&emsp;&emsp;如果可以不要求按程序顺序执行指令，那么就能进一步提高性能。&emsp;&emsp;为了支持乱序执行，将前述5段流水线的译码段（ID）细分为以下两个段：&emsp;&emsp;（1）流出：指令译码，并检查是否存在结构冲突。如果不存在结构冲突，就将指令流出。&emsp;&emsp;（2）读操作数：等待数据冲突消失，然后读操作数。&emsp;&emsp;可以看出，指令的流出还是按序流出，但它们在读操作数段可能停顿和互相跨越，因而进入执行段就可能已经乱序了。但是，原来不会发生的冲突在乱序执行时，就可能发生了。Tomasulo算法可以通过使用寄存器重命名来消除它们。&emsp;&emsp;采用动态调度的流水线支持多条指令同时处于执行状态，这是动态调度的一大优点。但这要求具有多个功能部件，或者流水功能部件，或者两者兼而有之。&emsp;&emsp;指令乱序完成大大增加了异常处理的复杂度。动态调度要保持正确的异常行为，即：只有那些在程序严格按程序顺序执行时会发生的异常，才能真正发生。为此动态调度处理机要做到：对于一条会产生异常的指令来说，只有当处理机确切地知道该指令将被执行后，才允许它产生异常。&emsp;&emsp;即使保持了正确的异常行为，动态调度处理机仍可能发生不精确异常。所谓不精确异常是指：当执行指令i导致发生异常时，处理机的现场（状态）与严格按程序顺序执行时指令i的现场不同。反之，如果发生异常时，处理机的现场跟严格按程序顺序执行时指令i的现场相同，就称为是精确异常。不精确异常使得在异常处理后难以接着继续执行程序。&emsp;&emsp;之所以会产生不精确的异常，是因为当一场发生（指令i）时：①流水线可能已经执行完按程序顺序是位于指令i之后的指令；②流水线可能还没完成按程序顺序是指令i之前的指令。&emsp;&emsp;记分牌算法和Tomasulo算法是两种比较典型的动态调度算法。Tomasulo算法比记分牌算法改进很多，是一种更强的算法。许多开发指令级并行的现代处理机都采用了Tomasulo算法或其变形。 Tomasulo算法]]></content>
      <categories>
        <category>专业知识</category>
      </categories>
      <tags>
        <tag>计算机系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指令级并行基本概念]]></title>
    <url>%2F2019%2F03%2F06%2F%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;自20世纪80年代中期以来，几乎所有的处理机都利用流水线来使指令重叠并行执行，以达到提高性能目的。这种指令之间存在的潜在并行性成为指令级并行（ILP）。通过利用各种技术，在流水线思想的基础上进一步扩展，开发出更多的指令级并行。&emsp;&emsp;开发ILP主要分为两类：主要基于硬件的动态开发以及基于软件的静态开发方法。在实际开发中，往往需要两者兼用。特别是，把硬件与软件技术以及动态的方法与静态方法结合起来，才能充分开发程序中潜在的指令级并行。&emsp;&emsp;流水线处理机的实际CPI等于理想流水线的CPI加上各类停顿的时钟周期： $$ CPI_{流水线}=CPI_{理想}+停顿_{结构冲突}+停顿_{数据冲突}+停顿_{控制冲突} $$ &emsp;&emsp;其中，CPI_{理想}是衡量流水线最高性能的一个指标。通过减少该式右边各项，就能减小总的CPI，从而提高IPC（Instructions Per Cycle，每个时钟周期完成的指令条数）。&emsp;&emsp;相关是程序固有的一种属性，它反映了程序中指令之间的相互依赖关系。而具体的一次相关是否会导致实际冲突的发生以及该冲突会带来多长的停顿，则是流水线的属性。&emsp;&emsp;主要从以下两个方面解决相关问题：&emsp;&emsp;（1）保持相关，但避免发生冲突。&emsp;&emsp;（2）通过代码变换，消除相关。&emsp;&emsp;指令调度是一种用以避免冲突的主要方法，但它不改变相关。通过动态调度代码的硬件方法，可以消除某些相关。&emsp;&emsp;由于相关的存在，必须保持程序顺序。程序书序是指，有源程序确定的在完全串行方式下指令的执行顺序。只有在可能影响程序正确性的情况下，才需要保持程序顺序。&emsp;&emsp;对于正确的执行程序来说，必须保持的最关键的两个属性是：数据流（data flow）和异常行为（exception behavior）。&emsp;&emsp;保持异常行为是指：无论怎么改变指令的执行顺序，都不能改变程序中异常的发生情况。&emsp;&emsp;如果能做到保持程序的数据相关和控制相关，就能保持程序的数据流和异常行为。]]></content>
      <categories>
        <category>专业知识</category>
      </categories>
      <tags>
        <tag>计算机系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2019%2F03%2F03%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>专业知识</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[向量处理机]]></title>
    <url>%2F2019%2F03%2F02%2F%E5%90%91%E9%87%8F%E5%A4%84%E7%90%86%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;为了充分发挥流水线的效率，实现高性能计算，有的流水线处理设置了向量数据表示和相应的向量指令。这种向量处理机成为向量处理机。（此处的向量和数组类似）不具有向量表示和相应的向量指令的处理机，称为标量处理机。向量处理机有专用型，其高性能是局限于求解那些可以转化为向量运算的问题。 向量处理方式&emsp;&emsp;主要有三种方式：①横向处理方式；②纵向处理方式；③纵横处理方式。 向量处理机的结构&emsp;&emsp;以CRAY-1机为例，介绍寄存器-寄存器型向量处理机的结构和特点。 功能部件&emsp;&emsp;共有12条可并行工作的单功能流水线，可分别流水地进行地址、向量、标量的各种运算。它为向量运算提供了6个单功能流水部件：整数加（3拍）、逻辑运算（2拍）、移位（4拍）、浮点加（6拍）、浮点乘（7拍）和浮点迭代求倒数（14拍）。每拍为一个时钟周期，12.5ns。 向量寄存器组V&emsp;&emsp;每个向量寄存器可以每拍向功能部件提供一个数据元素，或者每拍接受一个从功能部件来的结果元素。 标量寄存器S和快速暂存器T向量屏蔽寄存器VM提高向量寄存器性能的方法&emsp;&emsp;一般有以下方法：①设置多个功能部件，使它们并行工作；②采用链接技术，加快一串向量指令的执行；③采取循环开采技术，加快循环的处理；④采用多处理器系统，进一步提高性能。 设置多个功能部件&emsp;&emsp;通过设置多个独立的功能部件，提高性能。这行部件能并行工作并各自按照流水方式工作，从而形成了多条并行工作的运算操作流水线。 链接技术&emsp;&emsp;链接技术是指，具有先写后读相关的两条指令，在不出现功能部件冲突和源向量冲突的情况下，可以把功能部件链接起来进行流水处理，以达到加快执行的目的。链接特性是CRAY-1向量处理的一个显著特点。&emsp;&emsp;链接技术实际上可以看成流水线的定向技术在向量处理机中的应用。当前一个向量功能部件产生第一个结果并送到结果向量寄存器的入口时，将该结果立即送往下一个功能部件的入口，开始后续的向量处理操作。此后依次得到的中间结果都按此处理。这样，前面功能部件的结果元素一产生，就可以立即被后面功能部件所使用，而不用等结果向量全部产生后再来使用。&emsp;&emsp;进行向量链接时，除了要求无向量寄存器使用冲突和无功能部件使用冲突外，还有一些别的要求：&emsp;&emsp;（1）只有在前一条指令的第1个结果元素送入结果向量寄存器的那一个时钟周期才可以进行链接。如果错过这个时刻，就无法进行链接了，这是只好等一条指令全部执行完毕、释放相应的向量寄存器之后，才可能执行后面的指令。&emsp;&emsp;（2）当一条向量指令的两个源操作数分别是两条先行指令的结果寄存器时，要求先行的两条指令产生运算结果的时间必须相等，即要求有关功能部件的通过时间相等。&emsp;&emsp;（3）要进行链接执行的向量指令的向量长度必须相等，否则无法进行链接。 分段开采技术&emsp;&emsp;当向量的长度大于向量寄存器的长度时，必须把长向量分成长度固定的段，然后循环分段处理，每次循环只处理一个向量段。这种技术成为分段开采技术。将长向量分段成循环处理是由系统硬件和软件控制完成的，对程序员是透明的。 采用多处理机系统]]></content>
      <categories>
        <category>专业知识</category>
      </categories>
      <tags>
        <tag>计算机系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流水线基本概念及其性能指标]]></title>
    <url>%2F2019%2F02%2F28%2F%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%2F</url>
    <content type="text"><![CDATA[基本概念&emsp;&emsp;和工业生产中的流水线类似，在计算机系统中，把一个重复的过程，分解成若干个子过程，每个子过程由专门的功能部件来实现。将多个处理过程在时间上错开，依次通过各功能段，每个子过程都可以与其他子过程同时并行进行。这就是流水线技术。&emsp;&emsp;流水线中的每个字过程及其功能部件成为流水线的段或级，段与段之间互相连接形成流水线。流水线的段数成为流水线的深度。&emsp;&emsp;把流水线技术应用于运算的执行过程，形成运算操作流水线；吧流水线技术应用于指令的解释执行过程，形成指令流水线。流水线的工作过程常常采用时空图的方法描述。 流水线特点&emsp;&emsp;(1) 流水线把一个处理工程分解为若干子过程（段），每个子过程都由一个专门的功能部件实现。&emsp;&emsp;(2) 流水线中各段的时间应该尽可能相等。否则，将引起流水线阻塞、断流，因为时间长的段将成为流水线的瓶颈，此时流水线中的其他功能部件就不能充分发挥作用。&emsp;&emsp;(3) 流水线每个功能部件的后面都有一个缓冲寄存器（锁存器），称为流水寄存器。其作用是在相邻两段之间相互传送数据，保证提供后面要用到的数据，并把各段的处理工作互相隔离。&emsp;&emsp;(4) 流水线技术适合于大量重复的时序过程，只有在输入端不断地输入任务，才能充分发挥流水线的效率。&emsp;&emsp;(5) 流水线需要通过实践和排空时间。通过时间是第一个任务从进入到流出的时间段，排空时间是最后一个任务的时间段。在这两个时间段内，流水线都不是满载。效率未得到充分发挥。 流水线分类从完成功能角度&emsp;&emsp;(1)单功能流水线：只能完成一种固定功能的流水线。&emsp;&emsp;(2)多功能流水线：可以以各段进行不同的连接，而实现不同的功能的流水线。但要保证不能发成冲突。 按照同一时间段内各段之间的连接方式&emsp;&emsp;(1)静态流水线：在同一时间段内，多功能流水线的各段只能按照同一功能的连接工作。当按另一种连接实现其他功能时，必须等按照原来连接方式处理的所有任务都流出流水线之后，才能改变连接。&emsp;&emsp;(2)动态流水线：在同一时间段内，多功能流水线的各段可以按照不同连接，同时执行多种功能。 从流水点级别角度&emsp;&emsp;(1)部件级流水线（运算操作流水线）：它把处理机的算术处理运算部件分段，使得各种类型的运算操作能够按照流水方式进行。&emsp;&emsp;(2)处理机级流水线（指令流水线）：它是把指令的解释过程分成不同过程，按照流水方式处理。&emsp;&emsp;(3)处理机间流水线（宏流水线）：它是由两个或两个以上处理机串行连接起来，对同一数据流进行处理，每个处理机完成整个任务的一部分。前一个处理机的输出结果存入存储器中，作为后一个处理机的输入。这一般属于异构型多处理机系统，它对提高各处理机的效率有很大的作用。 从反馈角度&emsp;&emsp;(1)线性流水线：流水线的各段串行连接，没有反馈回路。&emsp;&emsp;(2)非线性流水线：流水线中除了有串行的连接外，还有反馈回路。常用于递归或组成多功能流水线。&emsp;&emsp;在非线性流水线中，一个重要的问题是确定什么时候向流水线引进新任务，才能使该任务不会与先前进入流水线的任务发生冲突——争用流水段。这就是非线性流水线的调度问题。 从任务流入流出角度&emsp;&emsp;(1)顺序流水线：流水线输出端任务流出的顺序与输入端任务流入的顺序完全相同。&emsp;&emsp;(2)乱序流水线，又称无序流水线、错序流水线、异步流水线。&emsp;&emsp;通常把指令执行部件中采用流水线的处理机成为流水线处理机。如果处理机不具有向量数据表示和向量指令，仅对标量数据进行流水处理，如IBM 360/91、Amdahl 470V/6，称为标量处理机。具有向量表示和向量指令的处理机，称为向量流水处理机。向量处理机是向量数据表示和流水技术的结合。 流水线性能指标&emsp;&emsp;主要有吞吐率、加速比和效率三个指标。 吞吐率&emsp;&emsp;吞吐率TP（ThroughPut）是指在单位时间内流水线所完成的任务数量或者输出结果的数量。 $ TP=\frac{n}{T_k} $ &emsp;&emsp;其中，n为任务数，$ {T_k} $ 是处理完成n个任务所用的时间。 &emsp;&emsp;由图知： $$ T_k=k \Delta t+ (n-1)\Delta t= (k+n-1) \Delta t $$ &emsp;&emsp;得出： $$ TP= \frac{n}{(k+n-1)\Delta t} $$ &emsp;&emsp;这种情况下最大吞吐率为： $$ TP_{max}= \lim {(n \rightarrow \infty)}\frac{n}{(k+n-1)\Delta t} = \frac{1}{\Delta t}$$ &emsp;&emsp;最大吞吐率与实际吞吐率的关系为： $$ TP= \frac{n}{k+n-1} TP_{max} $$ 解决流水线瓶颈问题常用方法&emsp;&emsp;1) 细分瓶颈段。&emsp;&emsp;2) 重复设置瓶颈段。 加速比&emsp;&emsp;完成同一批任务，不使用流水线所用的时间和使用流水线所用的时间之比称为流水线的加速比。&emsp;&emsp;设不使用流水线所用的时间$ T_s $, 使用流水线所用的时间为$ T_k $,则流水线的加速比为： $$ S= \frac {T_s}{T_k} $$ &emsp;&emsp;理想情况下，一条k段流水线完成n个连续任务所需要的时间为 $ T_k=(k+n-1) \Delta t $，不使用流水线技术，而采用顺序执行方式，完成n个任务所需要的时间为：$ T_s=nk \Delta t $。带入上述公式得到加速比： $$ S=\frac{nk }{(n+k-1) } $$ &emsp;&emsp;这种情况下流水线的最大技术比为： $$ S_{max}=\lim {(n \rightarrow \infty)} \frac{nk}{n+k-1}=k $$ 效率&emsp;&emsp;流水线的效率是指流水线中的设备实际使用时间和整个运行时间的比值，即流水线设备的利用率。&emsp;&emsp;理想状态下，如上面时空图所示，各段的效率是相同的。 $$ e_1=e_2=····=\frac{n \Delta t}{T_k}=\frac{n}{n+k-1} $$ &emsp;&emsp;整条流水线的效率为： $$ E=\frac{e_1+e_2+···+e_k}{k}=\frac{ke_1}{k}=\frac{kn \Delta t}{kT_k} $$ &emsp;&emsp;或： $$ E=\frac{n}{k+n-1} $$ &emsp;&emsp;最高效率为： $$ E_{max}=\lim{(n \rightarrow \infty)} \frac{n}{k+n-1}=1 $$ &emsp;&emsp;显然当$ n\rightarrow \infty $时，流水线的效率接近于1。这时流水线各段都趋于忙碌状态。上述公式也可写成： $$ E=TP \Delta t $$ $$ E=\frac{S}{k} $$ &emsp;&emsp;即流水线的效率是流水线实际加速比S与其段数k的比值。只有当$ E=1 , S=k $,实际极速比达到最大。&emsp;&emsp;引入时空图中，流水线的效率即为任务占用的时空面积和k个段总的时空面积之比。可以表示为： $$ E=\frac{n个任务实际占用的时空区}{k个段总的时空区} $$ &emsp;&emsp;画出时空图，根据上述公式计算效率，对于线性流水线、非线性流水线、多功能流水线、任务不连续等情况均使用。&emsp;&emsp;当各段时间不相等时，连续执行n个任务时，效率为： $$ E=\frac{n \sum\limits_{i=1}^k \Delta t_i}{k[\sum\limits_{i=1}^k \Delta t_i+ (n-1)max(\Delta t_1,\Delta t_2,···,\Delta t_k)]} $$ 流水线设计的若干问题瓶颈问题流水线的额外开销&emsp;&emsp;流水线的额外开销是指流水寄存器延迟和时钟偏移开销。流水寄存器需要建立时间和传输延迟。时钟偏移开销是指流水线中时钟到达各流水寄存器的最大差值时间。 冲突问题]]></content>
      <categories>
        <category>专业知识</category>
      </categories>
      <tags>
        <tag>计算机系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流水线的相关与冲突]]></title>
    <url>%2F2019%2F02%2F28%2F%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E7%9B%B8%E5%85%B3%E4%B8%8E%E5%86%B2%E7%AA%81%2F</url>
    <content type="text"><![CDATA[一段经典的5段流水线&emsp;&emsp;以一个经典的5段RISC（Reduced Instruction Set Computer，精简指令集计算机）流水线为例。&emsp;&emsp;一条指令的执行过程分为以下5个周期：&emsp;&emsp;1. 取指令周期（IF）&emsp;&emsp;根据PC指示的地址从存储器中取出指令并放入指令寄存器IR；同时PC值加4（假设每条指令占4个字节），指向顺序的下一条指令。&emsp;&emsp;2. 指令译码/读寄存器周期（ID）&emsp;&emsp;对指令进行译码，并用IR中的寄存器编号去访问通用寄存器组，读出所需的操作数。&emsp;&emsp;3. 执行/有效地址计算周期（EX）&emsp;&emsp;在这个周期，ALU对在上一个周期准备好的操作数进行运算或处理。不同指令所进行的操作不同：&emsp;&emsp;（1）存储器访问指令：ALU把所指定的寄存器的内容与偏移量相加，形成用于访存的有效地址。&emsp;&emsp;（2）寄存器-寄存器ALU指令：ALU按照操作码指定的操作对从通用寄存器组中读取的数据进行运算。&emsp;&emsp;（3）寄存器-立即数ALU指令：ALU按照操作码指定的操作对从通用寄存器组中读取的第一操作数和立即数进行运算。&emsp;&emsp;（4）分支指令：ALU把偏移量与PC值相加，形成转移目标地址。同时，对在前一个周期读出的操作数进行判断，确定分支是否成功。&emsp;&emsp;4. 存储器访问/分支完成周期（MEM）&emsp;&emsp;1）load和store指令&emsp;&emsp;如果是load指令，就用上一个周期计算出的有效地址从存储器中读取相应的数据；如果是store指令，就把指定的数据写入这个有效地址所指出的存储器单元。&emsp;&emsp;2）分支指令&emsp;&emsp;如果在前一个周期判定该分支“成功”，就把转移目标地址送入PC。分支指令完成。&emsp;&emsp;5. 写回周期（WB）&emsp;&emsp;ALU运算指令和load指令在这个周期把结果数据写入通用寄存器组。对于ALU运算指令来说，这个结果数据来自ALU，对于load指令，结果数据来自存储器系统。 相关&emsp;&emsp;相关是指两条指令之间存在某种依赖关系。有三中类型：数据相关（真数据相关），名相关，控制相关。 数据相关（data dependence）&emsp;&emsp;对于两条指令i和j（有先后关系），如下条件之一成立，则称有数据相关：&emsp;&emsp;（1）指令j使用指令i产生的结果。&emsp;&emsp;（2）指令j与指令k数据相关，指令k又与指令i数据相关。&emsp;&emsp;其中，第二个条件表明，数据相关具有传递性。 名相关（name dependence）&emsp;&emsp;这里的名是指指令所访问的寄存器或存储器单元的名称。如果两条指令使用相同的名，但是他们之间没有数据流动，则称这两条指令之间存在名相关。名相关有一下两种：&emsp;&emsp;（1）反相关。如果指令j写的名和指令i读的名相同，则称为反相关。&emsp;&emsp;（2）输出相关。如果指令i和j写的名相同，称为输出相关。&emsp;&emsp;名相关可以通过换名技术消除，即把其中一条指令所使用的名换成别的，并不影响另一条指令的正常执行 控制相关（control dependence）&emsp;&emsp;（此消除不能消除）控制相关是指由分支指令引起的相关。他需要根据分支指令的执行结果来确定后续指令是否执行。一般来说，为了保证程序应有的执行顺序，必须严格按控制相关确定的顺序执行。控制相关的一个简单例子是if语句中的then部分。 流水线冲突&emsp;&emsp;流水线冲突是指对于具体的流水线来说，由于相关的存在，使得指令流中的下一条指令不能在指定的时钟周期执行。&emsp;&emsp;流水线冲突有以下3中类型：&emsp;&emsp;（1）结构冲突：因硬件资源满足不了指令重叠执行的要求而发生的冲突。&emsp;&emsp;（2）数据冲突：当指令在流水线中重叠执行时，因需求用到指令的执行结果而发生的冲突。&emsp;&emsp;（3）控制冲突：流水线遇到分支指令和其他会改变PC值的指令所引起的冲突。 结构冲突&emsp;&emsp;当功能部件不是完全流水或资源不够时，往往发生冲突。&emsp;&emsp;解决方法是对功能部件进行流水或重复设置资源。 数据冲突&emsp;&emsp;数据冲突有三种：&emsp;&emsp;（1）写后读冲突：指令j用到指令i的计算结果，而且在i将结果写入寄存器之前就去读该寄存器，因而得到的是旧值。对应真数据相关。&emsp;&emsp;（2）写后写冲突：指令j和指令i的结果单元（寄存器或存储器单元）相同，而且j在i写入之前就先该单元进行了写入操作，从而导致了写入顺序错误。对应输出相关。&emsp;&emsp;前面介绍的5段流水线由于只发生在WB段写寄存器，不会发生写后写冲突。写后写冲突仅发生在这样的流水线中：①流水线中不止一个段可以进行写操作；②当先前某条指令停顿时，允许其后续指令继续前进。&emsp;&emsp;（3）读后写冲突：指令j的结果单元和指令i的源操作上述单元相同，而且j在i读取该单元之前就先对之进行了写入操作，导致i读取到的值是错误的。对应反相关。&emsp;&emsp;读后写冲突不会发生在前述5段流水线中，因为这种流水线中的所有读操作（在ID段）都在写结果前发生。此冲突发生在：①有些指令的写结果操作提前了，而且有些指令的读操作滞后了；或②指令被重写排序了。 通过定向技术减少数据冲突引起的冲突&emsp;&emsp;通过定向技术（旁路或短路技术）解决写后读冲突。&emsp;&emsp;关键思路是：在某条指令在产生计算结果前，其他指令并不真正立即需要该计算结果，如果能够将该计算结果从其产生的地方直接送到其他指令需要的地方，那么就可以避免停顿。实现方法：&emsp;&emsp;（1）EX段和MEM段之间的流水寄存器中保存的ALU运算结果总是送到ALU的入口。&emsp;&emsp;（2）当定向硬件检测到前一个ALU运算结果写入的寄存器就是当前ALU操作的源寄存器时，那么控制逻辑就选择定向的数据作为ALU的输入结果，而不采用从通用寄存器组读出的值。 需要停顿的数据冲突&emsp;&emsp;在某些不能通过定向技术等方法解决冲突时，需要设置一个“流水线互锁机制”的功能部件。来检测、发现数据冲突，并使得流水线停顿，直至冲突消失。在停顿处加入“气泡”。 依靠编译器解决数据冲突&emsp;&emsp;为减少冲突，对于无法用定向技术解决的数据冲突，可以通过在编译时让编译器重新组织指令顺序来消除冲突，称为“指令调度”或“流水线调度”。对于各种冲突，都有可能用指令调度来解决。 控制冲突&emsp;&emsp;控制冲突可能产生比数据冲突更多的性能损失。对于分支指令，有两种结果，一种是分支“成功”，PC改变为分支转移的目标地址。另一种是“不成功”或者“失败”，这是PC值保持正常递增，按原来顺序执行下一条指令。如果分支成功，在条件判定和转移地址计算都完成后，才改变PC值。对于前述5段流水线来说，改变PC值是在MEM段进行的。&emsp;&emsp;处理分支指令最简单的方法是“冻结”或“排空”流水线。即当出现分支指令时，立即停止以后的指令执行，知道分支指令结果确定。&emsp;&emsp;由分支指令引起的延迟称为分支延迟。&emsp;&emsp;为减少分支延迟，可采取以下措施：&emsp;&emsp;（1）在流水线中尽早判断出分支转移是否成功。&emsp;&emsp;（2）今草计算出分支目标地址。&emsp;&emsp;这两种措施缺一不可。只有两者都有时，才能进行转移。&emsp;&emsp;通过软件（编译器）减少分支延迟的方法主要有三种：预测分支成功，预测分支失败，延迟分支。 预测分支失败&emsp;&emsp;当分支指令出现时，沿失败的分支继续处理指令，当分支指令结果确定后，在按照结果，如果是分支失败，则辨明预测成功，继续执行；如果是分支成功，流水线就把分支指令之后取出的指令转化为空操作，并按照分支目标地址重新取指令执行。 预测分支成功&emsp;&emsp;与预测分支失败同理。 延迟分支&emsp;&emsp;这种方法主要是从逻辑上“延迟”分支指令的执行时间。把延迟分支看成是由原来的分支指令和若干延迟槽构成。在实际机器中，绝大多数情况下只有一个延迟槽。&emsp;&emsp;延迟分支的效率完全取决于编译器能否把有用的指令调度到延迟槽中。这也是一种指令调度技术。常用的调度方法有3种：从前调度，从目标出调度，从失败处调度。]]></content>
      <categories>
        <category>专业知识</category>
      </categories>
      <tags>
        <tag>计算机系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定量分析技术]]></title>
    <url>%2F2019%2F02%2F26%2F%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[计算机系统设计的定量原理以经常性事件为重点Amdahl定律&emsp;&emsp;此定律指出：加快某个部件执行速度所能获得的系统性能提升，受限于此部件的执行时间占系统中总执行时间的占比。&emsp;&emsp;系统加速比公式：&emsp;&emsp;&emsp;&emsp; 系统加速比=\frac {系统性能_{改进后}} {系统性能_{改进前}}=\frac {总执行时间_{改进前}} {总执行时间_{改进后}}&emsp;&emsp;设出定义：&emsp;&emsp;(1)可改进比例：在改进前的系统中，可改进部分的执行时间在总的执行时间中所占的比例。&emsp;&emsp;(2)部件加速比：可改进部分在改进后性能提高的倍数。它是改进前所需执行时间和改进后所需执行时间的比。&emsp;&emsp;由(1)(2)得出：&emsp;&emsp;&emsp;&emsp;总执行时间_{改进后}=\frac{可改进比例* 总执行时间_{改进前}}{部件极速比}+不可改进比例*总执行时间_{改进前}&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; =总执行时间_{改进前}* [(1-可改进比例)+ \frac{可改进比例}{部件加速比}]&emsp;&emsp;&emsp;&emsp;系统加速比=\frac {总执行时间_{改进前}} {总执行时间_{改进后}}&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; =\frac {1}{(1-可改进比例)+\frac{可改进比例}{部件加速比}} CPU性能公式&emsp;&emsp;&emsp;&emsp; CPU时间=执行程序所需的时钟周期数* 时钟周期时间&emsp;&emsp;其中，时钟周期时间是系统时钟频率的倒数，即时钟周期时间=\frac{1}{f}。&emsp;&emsp;引入新参数CPI（Cycles Per Instruction，每条指令的平均时钟周期数），有：&emsp;&emsp;&emsp;&emsp; CPI=\frac{执行程序所需的时钟周期数}{所执行的指令条数}&emsp;&emsp;则推出CPU性能公式：&emsp;&emsp;&emsp;&emsp; CPU时间=IC* CPI* 时钟周期时间&emsp;&emsp;其中，IC为所执行的指令条数。&emsp;&emsp;根据上述公式，得知CPU的性能取决于以下三个参数：&emsp;&emsp;&emsp;(1) 时钟周期时间：取决于硬件实现技术和计算机组成。&emsp;&emsp;&emsp;(2) CPI：取决于计算机组成和指令集结构。&emsp;&emsp;&emsp;(3) IC：取决于指令集结构和编译技术。&emsp;&emsp;其他公式：&emsp;&emsp;&emsp;&emsp; CPU时钟周期数=\sum\limits_{i=1}^n{(CPI_i*IC_i)}&emsp;&emsp;其中，{IC_i}为程序执行的过程中第i种指令出现的次数，{CPI_i}为执行第i种指令所需的平均时钟周期，n为指令的种数。&emsp;&emsp;&emsp;&emsp; CPU时间=CPU时钟周期数*时钟周期时间&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; =\sum\limits_{i=1}^n{(CPU_i*IC_i)* 时钟周期时间} &emsp;&emsp;&emsp;&emsp; CPI=\frac{时钟周期数}{IC}&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; = \frac{\sum\limits_{i=1}^n{(CPI_i*IC_i)}}{IC}&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; = \sum\limits_{i=1}^n{(CPI_i* \frac{IC_i}{IC})}&emsp;&emsp;其中，(\frac{IC_i}{IC})反映了第i种指令在程序执行过程中所占的比例。&emsp;&emsp;&emsp;&emsp;MIPS=\frac{f}{CPI} 程序的局部性原理计算机系统的性能评测执行时间和吞吐率基准测试程序&emsp;&emsp;用于测试和比较性能的基准测试程序的最佳选择是真实应用程序（例如编译器）。]]></content>
      <categories>
        <category>专业知识</category>
      </categories>
      <tags>
        <tag>计算机系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并行概念]]></title>
    <url>%2F2019%2F02%2F26%2F%E5%B9%B6%E8%A1%8C%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[基本概念&emsp;&emsp;指计算机系统在同一时刻或者同一时间间隔内进行多种运算或者操作。在时间上相互重叠。包括同时性与并发性两种含义。&emsp;&emsp; 同时性———两个或者两个以上事件在同一时刻发生。&emsp;&emsp; 并发性———两个或者两个事件在同一时间间隔内发生。 分类&emsp;&emsp;从处理数据角度：字串位串，字串位并，字并位串，字并位并。&emsp;&emsp;从执行程序角度：指令内部并行，指令级并行，线程级并行，任务级或过程级并行，作业或程序级并行。 发展单机系统中的发展&emsp;&emsp;通过“部件功能专用化”实现时间重叠；多体存储器和多操作部件都是通过资源重复形式发展，如将通用部件（如加法部件，减法部件等）重复设置多个，进一步发展成为并行处理机（阵列处理机）；通过模拟多处理机的功能，形成虚拟机，实现资源共享。 多级系统中的发展&emsp;&emsp;多机系统分为：同构型多处理机，异构型多处理机，分布式系统。反应在耦合度上，分为紧密耦合和松散耦合。称为紧密耦合系统（直接耦合系统）和松散耦合系统（间接耦合系统）。松散耦合系统又分为两种形式，一种是多台计算机和共享的外存储连接，通过功能专用化，把不同功能计算机处理的结果以文件或者数据集的形式送到共享外存储器，以供其他计算机继续处理。另一种是计算机网络，通过通信线路连接，实现了更大范围的资源共享。 提高并行性途径&emsp;&emsp;时间重叠，资源重复，资源共享。&emsp;&emsp;现行计算机系统中，经常是同时运用时间重叠和资源重复两种措施。 时间重叠&emsp;&emsp;在并行性概念中，引入时间概念，让多个处理过程在时间上相互错开，轮流重叠的使用同一套硬件设备的各个部分，以加快硬件周转而赢得速度。典型实例是流水线技术。 资源重复&emsp;&emsp;引入空间因素，通过重复设置硬件资源，大幅提高系统性能。 资源共享&emsp;&emsp;是一种软件方法，它使多个任务按一定时间顺序轮流使用一套硬件设备。多道程序、分时系统就是遵循这一途径产生。资源共享既降低了成本，又提高了计算机设备的利用率。]]></content>
      <categories>
        <category>专业知识</category>
      </categories>
      <tags>
        <tag>计算机系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纪录片《大明宫》]]></title>
    <url>%2F2019%2F02%2F24%2F%E7%BA%AA%E5%BD%95%E7%89%87%E3%80%8A%E5%A4%A7%E6%98%8E%E5%AE%AB%E3%80%8B%2F</url>
    <content type="text"><![CDATA[片尾曲《大明宫》(网易云) 前世风雨 后世尘烟 亭台宫阙 都成残垣 繁华落尽 王侯长眠 谁的功过 万世流传 时间蔓延 万代千年 人生太短暂 怎守江山 我站在人间 看风云变幻 任由残砖碎瓦 铭刻变迁 岁月流淌 历尽沧桑 昨日辉煌 今在何方 我思我想 亦歌亦狂 才闻欢笑 又见泪光 时间蔓延 万代千年 岁月走不完 朝代轮转 我站在人世间 数兴衰的循环 多想长生不老 再看江山 金碧辉煌 羽衣霓裳 人间天上 唯你无双 耀眼光芒 无尽惆怅 萦绕着每颗心 梦回大唐]]></content>
      <categories>
        <category>人文知识</category>
      </categories>
      <tags>
        <tag>纪录片</tag>
        <tag>历史</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown常用数学公式及符号]]></title>
    <url>%2F2019%2F02%2F23%2FMarkdown%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%8F%8A%E7%AC%A6%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[基本符号括号&emsp;&emsp;() [] 直接写就行，而 {} 则需要转义“\ { ” “\ }”。 （\和{}之间无空格) 上下标&emsp;&emsp;a_下标，b^上标：a_b， a^c。 分数 &emsp;&emsp;\frac {分子} {分母} ：\frac {分子} {分母}。 求和符号及其上下限位置默认情况下：&emsp;&emsp;默认行间公式\sum_{k=1}^n{x_k}上下限标注在上下： \sum_{k=1}^n{x_k}可强制修改：&emsp;&emsp;强制行间公式\sum\nolimits_{k=1}^n{x_k}上下限标注在右侧： \sum\nolimits_{k=1}^n{x_k}数学符号± ：\pm× ：\times÷：\div∣：\mid ⋅：\cdot∘：\circ∗: \ast⨀：\bigodot⨂：\bigotimes⨁：\bigoplus≤：\leq≥：\geq≠：\neq≈：\approx≡：\equiv∑：\sum∏：\prod∐：\coprod 集合运算符：∅：\emptyset∈：\in∉：\notin⊂：\subset⊃ ：\supset⊆ ：\subseteq⊇ ：\supseteq⋂ ：\bigcap⋃ ：\bigcup⋁ ：\bigvee⋀ ：\bigwedge⨄ ：\biguplus⨆：\bigsqcup 对数运算符：log ：\loglg ：\lgln ：\ln 三角运算符：⊥：\bot∠：\angle30∘：30^\circsin ：\sincos ：\costan ：\tancot ：\cotsec ：\seccsc ：\csc 微积分运算符：y′x：\prime∫：\int∬ ：\iint∭ ：\iiint∬∬：\iiiint∮ ：\ointlim ：\lim∞ ：\infty∇：\nabla 逻辑运算符：∵：\because∴ ：\therefore∀ ：\forall∃ ：\exists≠ ：\not=≯：\not&gt;⊄：\not\subset 戴帽符号：y^ ：\hat{y}\check{y} ：\check{y}y˘ ：\breve{y} 连线符号：a+b+c+d¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯：\overline{a+b+c+d}a+b+c+d−−−−−−−−−− ：\underline{a+b+c+d}a+b+c1.0+d2.0：\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0} 箭头符号：↑：\uparrow↓：\downarrow⇑ ：\Uparrow⇓：\Downarrow→：\rightarrow← ：\leftarrow⇒ ：\Rightarrow⇐ ：\Leftarrow⟶ ：\longrightarrow⟵ ：\longleftarrow⟹：\Longrightarrow⟸ ：\Longleftarrow 表达(向量,平均值,(线性回归，直线方程) y尖,无穷小,一阶导,二阶导)\vec{a} 向量$\overline{a}$ 平均值$\widehat{a}$ (线性回归，直线方程) y尖$\widetilde{a}$ 颚化符号 等价无穷小$\dot{a}$ 一阶导数$\ddot{a}$ 二阶导数a a¯ \overline{a}a aˆ \widehat{a}a a˜ \widetilde{a}a a˙ \dot{a}a˙ a¨ \ddot{a}a ¨作者：马不停蹄地忧伤来源：CSDN原文：https://blog.csdn.net/u013163834/article/details/87904444版权声明：本文为博主原创文章，转载请附上博文链接！ 参考链接：https://blog.csdn.net/xingxinmanong/article/details/78528791https://www.cnblogs.com/q735613050/p/7253073.htmlhttps://blog.csdn.net/thither_shore/article/details/52260742https://blog.csdn.net/qq_38228254/article/details/78515800]]></content>
      <tags>
        <tag>Markdown</tag>
        <tag>知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse Java开发采坑]]></title>
    <url>%2F2019%2F02%2F02%2FEclipse-Java%E5%BC%80%E5%8F%91%E9%87%87%E5%9D%91%2F</url>
    <content type="text"><![CDATA[eclipse无法解析导入 javax.servlet 的解决方法&emsp;&emsp;出现上述问题的原因是你的Eclipse项目没有导入JSP运行所需要的Tomcat类库，主要是servlet-api.jar文件(或者servlet.jar），tomcat容器里面有这文件，在以下位置：%Tomcat_Home%/common/lib/servlet-aip.jar,要将其导入到项目的构建路径中(如果你用的是Eclipse). &emsp;&emsp;导入方法：右击你的Eclipse项目，选择 “构建路径”—“配置构建路径”。点击“库”选项卡，单击右边的“添加库”按钮，在出现的“添加库”对话框中选中“服务器运行时”，单击“下一步”，在出现的对话框中选中你使用的Tomcat服务器,例如，我的是：Apache Tomcat v5.5,单击“完成”既可。这时你的Tomcat类库就添加到当前项目中了。&emsp;&emsp;依次展开Java Resources: src-&gt;Libraries，就能看到Apache Tomcat v5.5[Apache Tomcat v5.5]类库已经添加到当前项目中了。 request中的setCharacterEncoding方法不识别&emsp;&emsp;request中的setCharacterEncoding方法作用是用指定的编码集去覆盖request对象中的默认的”ISO-8859-1”编码集，这样request.getParameter(“”)方法就会用新的编码集去解码，必须在第一次使用request时就要调用这个方法来设置编码集，否则该方法就会无效。单独加载weblogic.jar，应为它会用到request上网上说servlet-api.jar版本必须在2.4之后面的方法都试过后，我的setCharacterEncoding（“utf-8”）方法依然不识别；简直气人啊；最后用 where java 命令查看安装的jdk发现jdk地址显示“c:\programData\Oracle\java\javapath……java.exe”和环境变量配置的地址不一样，果断删除，并将path环境变量里的jdk相关配置放到最前面。]]></content>
      <categories>
        <category>编程开发</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魅族魅蓝S6获取完整ROOT]]></title>
    <url>%2F2019%2F02%2F01%2F%E9%AD%85%E6%97%8F%E9%AD%85%E8%93%9DS6%E8%8E%B7%E5%8F%96%E5%AE%8C%E6%95%B4ROOT%2F</url>
    <content type="text"><![CDATA[参考链接https://romprovider.com/2018/07/meizu-s6-root-twrp/amp/https://tieba.baidu.com/p/6023374283]]></content>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《自题金山画像》小记]]></title>
    <url>%2F2018%2F11%2F08%2F%E3%80%8A%E8%87%AA%E9%A2%98%E9%87%91%E5%B1%B1%E7%94%BB%E5%83%8F%E3%80%8B%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[自题金山画像 苏轼 心似已灰之木，身如不系之舟。 问汝平生功业，黄州惠州儋州。 &emsp;&emsp;他题这首诗的时候，不知道会是悲戚的，还是无奈的。&emsp;&emsp;从眉山和父亲、弟弟出发时对未来的无限憧憬，在汴梁考场金榜题名时的意气风发，到文坛领袖的赏识，再到仕途前辈的提携，自己也奋力的展现自己的抱负理想，没想到随转直下的，是官场政敌的恶意诋毁，随之而来的是贬嘀出京，新党政敌倒台被召还朝，引不满旧党的腐败现象，进行抨击，至此苏轼是既不能容于新党，又不能见谅于旧党，再贬岭南，而后一贬再贬，颠沛流离在外大半生。&emsp;&emsp;直到又看到这幅画，题了这首诗，回顾了自己的前半生。虽然诗文名遍天下，却始终没能实现自己的政治抱负，但他应该还是乐观的，只因他是苏东坡，独一无二的苏东坡。]]></content>
      <categories>
        <category>生活杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
        <tag>苏轼</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用HEXO框架和GitHub搭建个人博客]]></title>
    <url>%2F2018%2F10%2F31%2F%E5%88%A9%E7%94%A8HEXO%E6%A1%86%E6%9E%B6%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架，可以方便的生成静态网页托管在GitHub和Heroku上。基本原理是用Git将hexo博客在本地编译后的文件，上传到GitHub，通过地址访问。通过此种方法看到的，严格上并不是一个网站系统，而只是托管在GitHub上的一堆静态网页。但我们可以在本地更新后，同步到GitHub来实现和网站系统一样的功能。 环境准备本地环境准备&emsp;&emsp;下载并安装Git&emsp;&emsp;下载并安装Node.js 账号注册&emsp;&emsp;注册GitHub账号 建站过程&emsp;&emsp;以下过程在Git中进行。 安装hexo1$ install hexo 本地调试123$ hexo clean;//清理$ hexo generate;//编译$ hexo sever;//开启本地服务 &emsp;&emsp;打开浏览器，通过http://localhost:4000访问。 在GitHub上创建存储库&emsp;&emsp;命名方式为：用户名.github.io。 修改 站点配置 文件_config.yml1234deploy: type: git repo: https://github.com/用户名/用户名.github.io branch: master 部署到GitHub&emsp;&emsp;第一次可能需要登录GitHub账户。1$ hexo deploy;//部署 访问&emsp;&emsp;通过 https://用户名.github.io 访问。 功能拓展更改主题&emsp;&emsp;可以再hexo官网查找主题，本站使用了next 主题。 启用本地搜索&emsp;&emsp;安装1$ npm install hexo-generator-searchdb --save &emsp;&emsp;修改 站点配置 文件_config.yml12345search: path: search.xml field: post format: html limit: 10000 &emsp;&emsp;修改 主题配置文件12local_search: enable: true 第三方评论&emsp;&emsp;可以使用LiveRe(来必力)等。 网站统计&emsp;&emsp;可以使用百度统计等。 更改访问域名 &emsp;&emsp;可以在github项目库setting中设置自己的域名。 &emsp;&emsp;在freenom.com 可以注册.ml, .tk等结尾的免费顶级域名。 博文撰写 &emsp;&emsp;可以用符合Markdown语法的软件写自己的博客。]]></content>
      <categories>
        <category>专业知识</category>
      </categories>
      <tags>
        <tag>NexT</tag>
        <tag>教程</tag>
        <tag>HEXO</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《魔道祖师》——每个人都是一个江湖]]></title>
    <url>%2F2018%2F10%2F28%2F%E3%80%8A%E9%AD%94%E9%81%93%E7%A5%96%E5%B8%88%E3%80%8B%E2%80%94%E2%80%94%E6%AF%8F%E4%B8%AA%E4%BA%BA%E9%83%BD%E6%98%AF%E4%B8%80%E4%B8%AA%E6%B1%9F%E6%B9%96%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;前段时间，不经意间看到了《魔道祖师》的动画，感觉很棒。无论是动画形象，题材。比那些大IP好很多，为了补贴经费啥都干，吃相太难看。苍山乱烟外，玉树微雨里。举目人不见，凄凄风又起。（来源网络） 引 前世的魏无羡万人唾骂，声名狼藉。 被情同手足的师弟带人端了老巢， 纵横一世，死无全尸。 曾掀起腥风血雨的一代魔道祖师，重生成了一个…… 脑残。 还特么是个人人喊打的断袖脑残！！ 我见诸君多有病，料诸君见我应如是。 但修鬼道不修仙，任你千军万马，十方恶霸，九州奇侠，高岭之花， 但凡化为一抔黄土，统统收归旗下，为我所用，供我驱策！ 主题曲歌词 风雨前尘 傲视苍穹 轻抚陈情亦从容 云深不知处 天子笑坛中 世事无常 独醉梦一场 探正邪两道 观世间喧嚣 孤一身战江湖 亦不曾 将内心辜负 潇洒人间道 善恶都离空 却抹不掉心中伤痕 这一世 浮生若梦 纵然与世无争 道不同义在心中 怎奈侠肝义胆 却成一场空 善恶是非分明 爱恨界限不清 相识就像是一场梦 轮回重生 恩怨迷蒙 似曾相识 露青锋 云景深处 琴瑟伴笛声 世事无常 独醉梦一场 观正邪两道 探世间喧嚣 并肩战江湖 从未曾 将内心辜负 潇洒人间道 善恶都离空 却抹不掉心中伤痕 这一世 与人无争 纵然与世无争 道不同义在心中 怎奈侠肝义胆 却成一场空 善恶是非分明 爱恨界限不清 相知就像是一场梦 纵然与世无争 道不同义在心中 怎奈侠肝义胆 却成一场空 善恶是非分明 爱恨界限不清 相知就像是一场梦 照片]]></content>
      <categories>
        <category>生活杂记</category>
      </categories>
      <tags>
        <tag>动漫</tag>
        <tag>魔道祖师</tag>
      </tags>
  </entry>
</search>
